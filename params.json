{"name":"N2O","tagline":"Erlang WebSocket Application Server","body":"N2O: Erlang Web Framework\r\n=========================\r\n\r\nNitrogen 2x Optimized\r\n---------------------\r\n\r\nInformation for Nitrogen users:\r\n\r\n* All actions are triggered through single endpoint\r\n* Dropped support of simple_brigde\r\n* Dependency on Micro BERT and optional XHR fallback only, no jQuery\r\n* BERT/MessagePack inside JSON and raw binaries\r\n* Enough compatibility with original Nitrogen to convert sites/elements to N2O\r\n* Proper id and class attributes\r\n* Several times faster that original Nitrogen\r\n* GProc process registry instead of nprocreg\r\n* Much faster ETS Session Handler\r\n\r\nNew features\r\n-----------\r\n\r\n* Secure Pickling with AES CBC 128 for events protection\r\n* Optimized for latency: deffered JavaScript rendering\r\n* XHR fallback through Bullet for legacy browsers\r\n* Clean codebase without additional layers\r\n* One process per page during lifetime\r\n* Works heavy coupled within Cowboy processes\r\n* Page construction from Erlang binaries\r\n* Custom template engines as elements: #dtl\r\n* Advanced element collection: #upload, #tags, #edit\r\n* Rapid REST apps prototyping with REST handlers\r\n\r\nWebSockets transport\r\n--------------------\r\n\r\nN2O was started as the first Erlang Web Framework that fully relies on \r\nWebSocket transport for client/server communication.\r\nCompatibility with Nitrogen was mostly retained and many new improvements were made.\r\nSuch as binary page construction, binary data transfer, events trigger over WebSocket channel,\r\nminumum process spawns, use of Cowboy processes to run N2O html rendering.\r\nN2O page rendering is several times faster than with the original Nitrogen.\r\n\r\nBinary events over WebSockets\r\n-----------------------------\r\n\r\nN2O does not use JSON to encode data transfer between client/server. \r\nInstead, all data communication is encoded with native \r\nErlang External Term Format. For that Berg.js library is used.\r\nIs it as simple as calling Bert.decode(msg) and this allows \r\nto avoid complexity on the server-side. \r\nPlease refer to http://bert-rpc.org for more information.\r\n\r\nOptimized for speed\r\n-------------------\r\n\r\nOriginal Nitrogen was tested in production under high-load and\r\nwe decided to drop nprocreg process registry along with\r\naction_comet process creation. N2O creates only a single\r\nprocess for async websocket handler, all async operations\r\nare handled within Cowboy processes.\r\n\r\nWhy Erlang in Web?\r\n------------------\r\n\r\nWe have measured the performance of most of the existing modern web frameworks\r\ncreated with functional languages and Cowboy is still the king. You can see\r\nraw HTTP performance of functional and C-like languages with\r\nconcurrent primitives (Go, D and Rust) on VAIO Z notebook\r\nwith i7640M processor:\r\n\r\n![WebServers](http://synrc.com/lj/webcompare/connections.png)\r\n\r\nN2O greatly outperforms Nitrogen stack and is only ~2X slower than\r\nthe raw HTTP Cowboy performance thus beating rendering performance\r\nof any other functional web framework several times over.\r\nIt is certanly faster than raw HTTP node.js performance!\r\n\r\nReference to list of modern web frameworks: http://gist.github.com/5HT/5522302\r\n\r\nDesktop and Mobile Applications\r\n-------------------------------\r\n\r\nThere are two approaches to design communications between client/server.\r\nThe first is called data-on-wire, where only data transfers on channel\r\nthrough RPC, REST in form of JSON, XML or Binary. All rendering in first\r\ntype are being made on client side. This calls rich client and mostly\r\nfits for desktop. The examples are Chaplin/CoffeScript and Meteor/JavaScript.\r\n\r\nThe other approach is to send server prerendered part of pages and javascript,\r\nand on client side only replace HTML parts and execute JavaScript.\r\nThis approach better fits for mobile applications, where client doesn't\r\nhave much resources.\r\n\r\nUsing N2O you could create both types of applications: using N2O REST framework\r\nfor first type of application based on Cowboy REST features along with\r\nDTL templates for initial HTML renderings, and also Nitrogen DSL-based approach to model\r\nparts of the pages as widgets and control elements thanks\r\nto rich Nitrogen elements collections provided by Nitrogen community.\r\n\r\nSo, in cases when your system is built around Erlang infrastructure,\r\nN2O is the best choice that you could made for fast prototyping,\r\nsimpicity of use, codebase maintanance, etc. Despite HTML tranfer over the wire,\r\nyou will still have access to all your erlang services directly.\r\n\r\nTemplates vs DSL\r\n----------------\r\n\r\nWe liked Nitrogen for simple and elegant way of typed HTML\r\npage construction with DSL base on host language similar to\r\nScala Lift, OCaml Ocsigen and Haskell Blaze. It helps to develop\r\nreusable control elements and components in host language.\r\n\r\nTemplate-based approach pushes programmers to\r\ndeal with raw HTML, like Yesod, ASP, PHP, JSP, Rails, Yaws,\r\nChicagoBoss. It help to define the page in terms of top-level \r\nconsist of controls, playholders and panels. So N2O combine both approaches.\r\n\r\nMain N2O attraction is the fast prototyping. We also use it\r\nin large scale projects. Here is the complete Web Chat example\r\nworking with WebSockets that demonstrate the use of Templates, DSL\r\nand async interprocesses communications:\r\n\r\n    -module(chat).\r\n    -compile(export_all).\r\n    -include_lib(\"n2o/include/wf.hrl\").\r\n\r\n    main() ->\r\n        Title = wf_render_elements:render_elements(title()),\r\n        Body = wf_render_elements:render_elements(body()),\r\n        [ #dtl{file = \"index\", bindings=[{title,Title},{body,Body}]} ].\r\n\r\n    title() -> <<\"N2O\">>.\r\n\r\n    body() -> %% area of http handler\r\n        {ok,Pid} = wf:comet(fun() -> chat_loop() end),\r\n      [ #span { text= <<\"Your chatroom name: \">> },\r\n        #textbox { id=userName, text= <<\"Anonymous\">> },\r\n        #panel { id=chatHistory, class=chat_history },\r\n        #textbox { id=message },\r\n        #button { id=sendButton, text= <<\"Send\">>,\r\n                  postback={chat,Pid}, source=[userName,message] },\r\n        #panel { id=status } ].\r\n\r\n    event({chat,Pid}) -> %% area of websocket handler\r\n        Username = wf:q(userName),\r\n        Message = wf:q(message),\r\n        Terms = [ #span { text=\"Message sent\" }, #br{} ],\r\n        wf:insert_bottom(chatHistory, Terms),\r\n        wf:reg(room),\r\n        Pid ! {message, Username, Message};\r\n\r\n    event(Event) -> error_logger:info_msg(\"Unknown Event: ~p\", [Event]).\r\n\r\n    chat_loop() -> %% background worker ala comet\r\n        receive\r\n            {message, Username, Message} ->\r\n                Terms = [ #span { text=Username }, \": \",\r\n                          #span { text=Message }, #br{} ],\r\n                wf:insert_bottom(chatHistory, Terms),\r\n                wf:flush(room); %% we flush to websocket process by key\r\n            Unknown -> error_logger:info_msg(\"Unknown Looper Message ~p\",[Unknown])\r\n        end,\r\n        chat_loop().\r\n\r\nAnd try to compare how this functionality would be implemented\r\nwith your favourite language/framework.\r\n\r\nClean codebase\r\n------------------------------\r\n\r\nWe feel free to break some of the compatability with the original Nitrogen project,\r\nmostly because we want to have a clean codebase and fastest speed.\r\nHowever, it is still possible to easily port Nitrogen web sites to N2O.\r\nE.g. N2O returns id and class semantics of HTML and not html_id.\r\nWe simplified rendering by not using html_encode which should be handled by the application layer.\r\nNitrogen.js that was originally created by Rusty Klophaus, has been removed due to pure simplified\r\nWebSocket nature of N2O. We added XHR fallback handling through Extend Bullet by Loïc Hoguin.\r\nWe dropped simple_bridge and optimize N2O on every level for you to be sure its fastest way\r\nto develop application on erlang.\r\n\r\n    <input id=\"sendButton\" type=\"button\" class=\"sendButton button\" value=\"Send\"/>\r\n    <script>$('#sendButton').bind('click',function anonymous(event) {\r\n          ws.send(Bert.encodebuf({source: Bert.binary('sendButton'),\r\n                                  pickle: Bert.binary('R2LH0INQAAAAWXicy2DKYEt...'),\r\n                                  xforms: Bert.binary('undefined')}));});</script>\r\n\r\nReduced Latency\r\n---------------\r\n\r\nThe secret of reduced latency is simple. We try to deliver rendered HTML as soon as\r\npossible and render JavaScript only after WebSocket initialization. We use thre steps\r\nand three erlang processes for achieve that.\r\n\r\n![N2O Page Lifetime](http://synrc.com/lj/page-lifetime.png)\r\n\r\nIn first HTTP handler we render only HTML and all created by the way action is\r\nstored in created transition process. \r\n\r\n    transition(Actions) -> receive {'N2O',Pid} -> Pid ! Actions end.\r\n\r\nHTTP handler dies immediately after terurning HTML. Transition process waits for\r\nretrival request from future WebSocket handler.\r\n\r\nJust after receiving HTML browser initiates WebSocket connection and WebSocket\r\nhandler arise. After returning actions transition process dies and from now on\r\nWebSocket handler stay alone. Thus initial phase done.\r\n\r\nAfter that through WebSocket channel all event comes from browser to server and\r\nhandler by N2O, who renders elements to HTML and actions to JavaScript.\r\n\r\nPerformance\r\n-----------\r\n\r\nWe are using for measurement ab, httperf, wrk and siege, all of them. The most valuable storm\r\ncreated by wrk and it is not achieved in real apps but could show us the internal throughput\r\nof individual components. The most near to real life apps is siege who also make DNS lookup\r\nfor each request. So this data shows internal data throughput by wrk:\r\n\r\n| Framework | Enabled Components | Speed | Timeouts |\r\n|-----------|--------------------|-------|----------|\r\n| PHP5 FCGI | Simple script with two <?php print \"OK\"; ?> terms inside | 5K | timeouts |\r\n| Nitrogen  | No sessions, No DSL, Simple template with two variable | 1K | no |\r\n| N2O       | All enabled, sessions, Template, heavy DSL | 7K | no |\r\n| N2O       | Sessions enabled, template with two variables, no DSL | 10K | no |\r\n| N2O       | No sessions, No DSL, only template with two vars | 15K | no |\r\n\r\nPrerequisites\r\n-------------\r\n\r\nTo run N2O sites you need Erlang R15 or higher and basho rebar installed.\r\nN2O works on Windows, Mac and Linux. \r\n\r\nNOTE: the work of sync application on Windows is limited.\r\n\r\n    $ sudo apt-get install build-essential libncurses5-dev openssl libssl-dev m4\r\n    $ curl -O https://github.com/spawngrid/kerl/blob/master/kerl\r\n    $ chmod a+x kerl\r\n    $ echo KERL_CONFIGURE_OPTIONS=\"--enable-threads --enable-smp-support \\\r\n           --enable-m64-build --without-javac --enable-kernel-poll\" > ~/.kerlrc\r\n    $ kerl update releases\r\n    $ kerl build R16B01 r16b01\r\n    $ kerl install r16b01 /usr/lib/erlang\r\n    $ . /usr/lib/erlang/activate\r\n\r\nKickstart Bootstrap\r\n-------------------\r\n\r\nTo try N2O you just need to clone a N2O repo from Github and build. We don’t use fancy\r\nscripts so building process is OTP compatible: bootstrap site is bundled as Erlang release.\r\n\r\n    $ cd n2o/samples\r\n    $ make && make console\r\n\r\nNow you can try: [http://localhost:8000](http://localhost:8000)\r\n\r\nStart yourself depending N2O core\r\n---------------------------------\r\n\r\nIf you want dependency on the raw N2O core you should define\r\nN2O http and websocket (ws endpoint) cowboy handlers and cowboy static handler as\r\nCowboy dispatch parameter:\r\n\r\n    cowboy:start_http(http, 100, [{port, 8000}],\r\n                                 [{env, [{dispatch, dispatch_rules()}]}]),\r\n\r\n\r\n    dispatch_rules() ->\r\n        cowboy_router:compile(\r\n           [{'_', [\r\n                {[\"/static/[...]\"], cowboy_static,\r\n                    [{directory, {priv_dir, ?APP, [<<\"static\">>]}},\r\n                     {mimetypes, {fun mimetypes:path_to_mimes/2, default}}]},\r\n                {\"/ws/[...]\", bullet_handler, [{handler, n2o_bullet}]},\r\n                {'_', n2o_cowboy, []}\r\n        ]}]).\r\n\r\nAnd put minimal index.erl page:\r\n\r\n    -module(index).\r\n    -compile(export_all).\r\n    -include_lib(\"n2o/include/wf.hrl\").\r\n\r\n    main() -> [ #span{text = <<\"Hello\">>} ].\r\n\r\nDeveloper scripts for Sync\r\n--------------------------\r\n\r\nFor developing we use some scripts which are needed for linking source\r\ndirectories with release lib directories and also links to BERT, N2O\r\nand jQuery javascript. After making release you should run:\r\n\r\n    $ ./nitrogen_static.sh\r\n    $ ./release_sync.sh\r\n\r\nNow you can edit site sources and sync will automaticaly recompile\r\nand reload modules in release.\r\n\r\nSupport\r\n-------\r\n\r\n* IRC Channel #n2o on FreeNode 24/7\r\n* Official N2O Book [HTML](http://synrc.com/framework/web/) and [PDF](http://synrc.com/framework/web/n2o/doc/book.pdf)\r\n\r\nCredits\r\n-------\r\n\r\n* Maxim Sokhatsky -- core, shen\r\n* Dmitry Bushmelev -- endpoints, yaws, cowboy\r\n* Andrii Zadorozhnii -- elements, actions, handlers\r\n* Anton Logvinenko -- doc\r\n* Vladimir Kirillov -- mac, bsd, xen, linux support\r\n* Roman Shestakov -- advanced elements, ct\r\n* Jesse Gumm -- nitrogen, help\r\n* Rusty Klophaus -- original author\r\n\r\nOM A HUM\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}